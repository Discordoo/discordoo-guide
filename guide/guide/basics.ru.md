# Основные основы
Чем отличается библиотека?

Эта статья ответит на данный вопрос. (чуть позже будет ещё несколько пунктов, пока только один)

## Чем отличается библиотека
1. Первое и самое важное - эта библиотека не для новичков. Начиная работать с discordoo, вы должны знать JavaScript или TypeScript. Вы должны знать что такое кэш, как правильно организовывать код с большим количеством асинхронных функций и т.п. Также вы должны чётко понимать, зачем переходите на эту библиотеку, иначе вы сломаете голову в попытках понять, почему же в условном discord.js после удаления сообщения возвращается сообщение, а в discordoo - значение true/false: "Что за бред? Это же так логично!". Знающие люди после просмотра [этой ссылки](https://discord.com/developers/docs/resources/channel#delete-message) сразу поймут в чём дело и почему в discordoo именно так.
2. Асинхронный кэш - это то, на чём построена главная фишка библиотеки: гибкость в работе уровня "Я хочу хранить кэш в mongodb!". Если в условном discord.js или eris вы пишете `message.author.id === '123'`, то в discordoo вам придётся сначала получить author с помощью `await message.author()`, и только потом работать с author. Но зачем это всё? Из-за того, что кэш в discordoo очень гибок (можно не кэшировать что-либо, хранить кэш не только в памяти процесса и т.п.) - необходимо отделять объекты кэша друг от друга. Также это позволяет использовать кэш, который хранится на другом шарде так, будто он находится на текущем шарде. 
3. Отсутствие привязки к структурам. Если вы хотите отправить сообщение имея лишь айди канала - библиотека позволит это сделать. Если в discord.js нужно писать что-то вроде: `guild.channels.cache.get('123').send('hello world!')`, то в discordoo: `client.messages.create('123', 'hello world!')`. В то же время никто не запрещает использовать структуры для различных действий: `const channel = await guild.channels.cache.get('123'); channel.send('hello world')` - почти то же самое что и в discord.js, только напичкано функционалом, который вам ещё предстоит изучить.
4. Производительность. Знакомо то чувство, когда вы смотрите на график использования ЦП, а потом с удивлением обнаруживаете, что команда вашего бота на discord.js с информацией о сервере, где показаны онлайн и офлайн участники, при использовании на серверах с несколькими тысячами участников съедает 90% времени ЦП? Мне знакомо. Конкретную причину почему так происходит мы в данный момент опустим. А как часто вы, если у вас есть бот на discord.js, используете `client.emojis`? Если ни разу, то вам крупно повезло: ведь d.js в этом менеджере каждый вызов создаёт новую коллекцию из *всех* смайликов клиента, со всех серверов. То есть было у вас 100 мегабайт кэша смайликов, вы вызвали `client.emojis.cache.size`, а теперь у вас 200 мегабайт кэша смайликов. И неизвестно сколько времени ЦП было потрачено на создание этого кэша. Если повезёт, ненужный кэш сразу же очистится. А если ваш код как-то заставит держать этот кэш в памяти, то будьте добры, ожидайте прихода Garbage Collector, а пока он не придёт, на 10ом вызове `client.emojis.cache.size` кэш смайликов будет составлять уже не 100мб, а 1гб. В discordoo нет ни первого, ни второго случая: мы следим за тем, чтобы наш код не создавал такие ужасные просадки производительности. 
5. Гибкость для самых продвинутых: может быть, вы сейчас на detritus.js и вам запало в душу, насколько у этой библиотеки стабильная и быстрая работа с gateway? Не вопрос: потратьте 15 минут на создание провайдера (или найдите существующий), который использует их gateway, подключите к discordoo. Теперь discordoo будет использовать их gateway для работы. То же самое с рест апи и кэшированием. Хотите хранить кэш в монге - создайте провайдер или найдите существующий, подключите, всё работает. Не знаю, правда, зачем вам нужен кэш в монге, но не мне решать как вам ботов писать.
6. Шардинг нового уровня. Забудьте о fetchClientValues и broadcastEval. Нужно узнать количество серверов у бота? `client.guilds.cache.size({ shard: 'all' })`. Проверить наличие смайлика в кэше? `client.emojis.cache.has('123', { shard: 'all' })`. Получить мембера с другого шарда со всем функционалом? `client.members.cache.get('123', { shard: 33 })`. Отфильтровать участников сервера с другого шарда? `const guild = await client.guilds.cache.get('123', { shard: 33 }); const filtered = await guild.members.cache.filter(m => m.userId === '123', { shard: 33 }); console.log(filtered.length)`. Довольно этих странных нагромождений эвалов из-за межпроцессных запросов. 
7. Кэш нового уровня. Помимо асинхронности, вы можете сэкономить гигабайты оперативной памяти, даже не удаляя ненужный кэш: библиотека умеет хранить кэш в классах (используется по-умолчанию), в json объектах, в строках или в buffer - это позволяет использовать для хранения кэша сторонние хранилища. 500 мегабайт на 1 000 000 участников в кэше - реальность. А если вы не хотите заниматься подобными делами, но хотите сэкономить оперативки, просто не храните абсолютно любой кэш, который не используете лично вы: вплоть до отключения кэша серверов. 
