{"files":[{"file":"basics","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Library Basics\nThis article is in the process of writing. See you soon!\n"},{"file":"basics.ru","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Основные основы\nЧем отличается библиотека?\n\nЭта статья ответит на данный вопрос. (чуть позже будет ещё несколько пунктов, пока только один)\n\n## Чем отличается библиотека\n1. Первое и самое важное - эта библиотека не для новичков. Начиная работать с discordoo, вы должны знать JavaScript или TypeScript. Вы должны знать что такое кэш, как правильно организовывать код с большим количеством асинхронных функций и т.п. Также вы должны чётко понимать, зачем переходите на эту библиотеку, иначе вы сломаете голову в попытках понять, почему же в условном discord.js после удаления сообщения возвращается сообщение, а в discordoo - значение true/false: \"Что за бред? Это же так логично!\". Знающие люди после просмотра [этой ссылки](https://discord.com/developers/docs/resources/channel#delete-message) сразу поймут в чём дело и почему в discordoo именно так.\n2. Асинхронный кэш - это то, на чём построена главная фишка библиотеки: гибкость в работе уровня \"Я хочу хранить кэш в mongodb!\". Если в условном discord.js или eris вы пишете `message.author.id === '123'`, то в discordoo вам придётся сначала получить author с помощью `await message.author()`, и только потом работать с author. Но зачем это всё? Из-за того, что кэш в discordoo очень гибок (можно не кэшировать что-либо, хранить кэш не только в памяти процесса и т.п.) - необходимо отделять объекты кэша друг от друга. Также это позволяет использовать кэш, который хранится на другом шарде так, будто он находится на текущем шарде. \n3. Отсутствие привязки к структурам. Если вы хотите отправить сообщение имея лишь айди канала - библиотека позволит это сделать. Если в discord.js нужно писать что-то вроде: `guild.channels.cache.get('123').send('hello world!')`, то в discordoo: `client.messages.create('123', 'hello world!')`. В то же время никто не запрещает использовать структуры для различных действий: `const channel = await guild.channels.cache.get('123'); channel.send('hello world')` - почти то же самое что и в discord.js, только напичкано функционалом, который вам ещё предстоит изучить.\n4. Производительность. Знакомо то чувство, когда вы смотрите на график использования ЦП, а потом с удивлением обнаруживаете, что команда вашего бота на discord.js с информацией о сервере, где показаны онлайн и офлайн участники, при использовании на серверах с несколькими тысячами участников съедает 90% времени ЦП? Мне знакомо. Конкретную причину почему так происходит мы в данный момент опустим. А как часто вы, если у вас есть бот на discord.js, используете `client.emojis`? Если ни разу, то вам крупно повезло: ведь d.js в этом менеджере каждый вызов создаёт новую коллекцию из *всех* смайликов клиента, со всех серверов. То есть было у вас 100 мегабайт кэша смайликов, вы вызвали `client.emojis.cache.size`, а теперь у вас 200 мегабайт кэша смайликов. И неизвестно сколько времени ЦП было потрачено на создание этого кэша. Если повезёт, ненужный кэш сразу же очистится. А если ваш код как-то заставит держать этот кэш в памяти, то будьте добры, ожидайте прихода Garbage Collector, а пока он не придёт, на 10ом вызове `client.emojis.cache.size` кэш смайликов будет составлять уже не 100мб, а 1гб. В discordoo нет ни первого, ни второго случая: мы следим за тем, чтобы наш код не создавал такие ужасные просадки производительности. \n5. Гибкость для самых продвинутых: может быть, вы сейчас на detritus.js и вам запало в душу, насколько у этой библиотеки стабильная и быстрая работа с gateway? Не вопрос: потратьте 15 минут на создание провайдера (или найдите существующий), который использует их gateway, подключите к discordoo. Теперь discordoo будет использовать их gateway для работы. То же самое с рест апи и кэшированием. Хотите хранить кэш в монге - создайте провайдер или найдите существующий, подключите, всё работает. Не знаю, правда, зачем вам нужен кэш в монге, но не мне решать как вам ботов писать.\n6. Шардинг нового уровня. Забудьте о fetchClientValues и broadcastEval. Нужно узнать количество серверов у бота? `client.guilds.cache.size({ shard: 'all' })`. Проверить наличие смайлика в кэше? `client.emojis.cache.has('123', { shard: 'all' })`. Получить мембера с другого шарда со всем функционалом? `client.members.cache.get('123', { shard: 33 })`. Отфильтровать участников сервера с другого шарда? `const guild = await client.guilds.cache.get('123', { shard: 33 }); const filtered = await guild.members.cache.filter(m => m.userId === '123', { shard: 33 }); console.log(filtered.length)`. Довольно этих странных нагромождений эвалов из-за межпроцессных запросов. \n7. Кэш нового уровня. Помимо асинхронности, вы можете сэкономить гигабайты оперативной памяти, даже не удаляя ненужный кэш: библиотека умеет хранить кэш в классах (используется по-умолчанию), в json объектах, в строках или в buffer - это позволяет использовать для хранения кэша сторонние хранилища. 500 мегабайт на 1 000 000 участников в кэше - реальность. А если вы не хотите заниматься подобными делами, но хотите сэкономить оперативки, просто не храните абсолютно любой кэш, который не используете лично вы: вплоть до отключения кэша серверов. \n"},{"file":"index","dir":"/home/runner/work/guide/guide/guide/guide/","content":"---\nhide:\n- toc\n---\n\n# The Discordoo Guide\nHi there! This is The Discordoo Guide. Here you will learn the basics of working with Discordoo and creating your own Discord bot.\n\n## Important notice\nThis guide is intended to be read by people, who know TypeScript/Javascript and Node.js on\nbeginners level. We will not help you if you don't know how to use Node.js or\nwrite basic TypeScript/JavaScript code.\n"},{"file":"index.ru","dir":"/home/runner/work/guide/guide/guide/guide/","content":"---\nhide:\n- toc\n---\n\n# The Discordoo Guide для начинающих\nПривет! Вы попали на главную страницу The Discordoo Guide для начинающих.\n\nЗдесь находятся инструкции, которые могут пригодиться при разработке любого Discord бота. \nЕсли вы только узнали о библиотеке, начните с [установки](./installing.ru.md). \nА затем прочтите статью [о написании первого кода и запуске](./starting.ru.md) вашего бота.\n\n## И всё?\nПока это весь гайд. Библиотека ещё в разработке и гайд будет написан после релиза.\n"},{"file":"installing","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Installing Discordoo\nIn this step, you will know how to install Discordoo.\n\nDiscordoo is located under `discordoo` package and `@discordoo` organization.\n\n## Let's start\nFirst of all, you need to have a **node.js version 12.18** or higher. \nIf you want to use typescript in your project, **typescript version must be 4.2.2** or higher.\n\n### npm\nCurrently, our package is only available on npm. So, install it:\n```sh\n# via npm\nnpm i discordoo\n# via yarn\nyarn add discordoo\n```\n\n## Ecosystem\nIn addition to the main package, we have others: for example, you can use Discordoo's collection separately without installing Discordoo. In the future, we will have several additional packages that will help you develop your bots.\n\nAs I said above, collection can be installed separately:\n```sh\n# via npm\nnpm i @discordoo/collection\n# via yarn\nyarn add @discordoo/collection\n```\n\n"},{"file":"installing.ru","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Установка Discordoo\nDiscordoo представляет собой пакет `discordoo`, а также разные пакеты, находящиеся в организации `@discordoo`.\n\n## Начнём\nВам потребуется **Node.js версии 12.18** или выше.\nЕсли вы хотите использовать TypeScript в своём боте, его версия должна быть 4.2.2 или выше.\n\n### npm\nПока что Discordoo находится только в реестре npm. Вы можете установить её так:\n```sh\n# через npm\nnpm i discordoo\n# или через yarn\nyarn add discordoo\n```\n\n## Экосистема\nВ дополнение к основному пакету `discordoo` мы разрабатываем несколько других: например, вы можете использовать нашу коллекцию без установки основного пакета. В будущем мы добавим ещё несколько пакетов, которые помогут вам в разработке ботов.\n\nКоллекцию можно установить вот так:\n```sh\n# через npm\nnpm i @discordoo/collection\n# или через yarn\nyarn add @discordoo/collection\n```\n"},{"file":"starting","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Starting your bot\nWe provide `createApp` function, which allows you to create a bot and add any options to it.\n\n=== \"JS\"\n```js\nconst { createApp } = require('discordoo')\n\nconst client = createApp('discord-bot-token').build()\n\nclient.start()\n  .then(() => console.log('online!'))\n```\nThe easiest and fastest way to create and connect a bot to Discord is shown above.\n\nBut this bot can't do anything. Let's teach it how to react to `/` commands:\n\n--- **IN DEVELOPMENT** ---\n\n=== \"JS\"\n\n```js\nconst { createApp, AdvancedEventsGatewayProvider } = require('discordoo')\n\nconst client = createApp('discord-bot-token')\n  .gatewayProvider(AdvancedEventsGatewayProvider)\n  .build()\n\nclient.on('slashCommand', async command => {\n  if (command.name === 'ping') {\n    await command.reply('pong!')\n  }\n})\n\nclient.start().then(async () => {\n  const commands = [ \n    // command names can contain only a-z, numbers and -. also, they must be lower-case and up to 32 in length.\n    { name: 'ping', description: 'pong!' }\n  ]\n  \n  if (!await client.app.commands.cache.size()) {\n    await client.app.commands.register(commands)\n  }\n})\n```\nHere we use the built-in gateway provider with new events to detect `/` commands.\nAfter the bot connects to the discord, we check whether it has a `/` commands. If there are none, then we add them.\nWe are adding global commands to the bot - they will be available on any servers where the bot is added.\n\n"},{"file":"starting.ru","dir":"/home/runner/work/guide/guide/guide/guide/","content":"# Первый код и запуск\nОсновной способ создания и настройки нового бота - функция `createApp`. Используйте её:\n\n=== \"JS\"\n```js\nconst { createApp } = require('discordoo')\n\n// discord-bot-token - токен вашего бота. Не бойтесь, мы его не украдём.\nconst client = createApp('discord-bot-token').build()\n\nclient.start()\n  .then(() => console.log('online!'))\n```\nЭто самый быстрый и простой способ.\n\nВот только такой бот ничего не умеет, он только висит онлайн. Давайте научим его реагировать на простейшие команды:\n\n=== \"JS\"\n```js\nconst { createApp } = require('discordoo')\n\nconst client = createApp('discord-bot-token').build()\n\nclient.on('messageCreate', async context => {\n  /**\n   * Здесь мы видим переменную context. \n   * Так как Discordoo - во всех смыслах гибкая библиотека, разработчик может отключать любой кэш библиотеки.\n   * Поэтому в ивентах мы используем context вместо обычной передачи данных напрямую.\n   * В подобных переменных содержится сопутствующая информация об ивенте.\n   * В данном случае, это MessageCreateEventContext, и внутри этого контекста гарантированно передаётся \n   * сообщение, а также его автор. Эти данные присылает сам Discord внутри ивента.\n   * Также в context передаётся канал, в котором было написано сообщение. \n   * Но, т.к. данные о канале Discord в этом ивенте не передаёт, библиотека пытается найти канал в кэше и передать.\n   * Если библиотека не сможет найти канал сообщения в кэше, в контексте этого ивента канал передан не будет.\n   * Таким образом построена передача данных в любом ивенте - есть context, \n   * в нём есть гарантированные и негарантированные свойства. \n   * Узнать о содержании определённого контекста можно вбив в поиск этой документации <НазваниеИвента>EventContext,\n   * например MessageCreateEventContext.\n   * */\n  \n  const { message, author, channel, channelId } = context\n  \n  /**\n   * Кэш в Discordoo асинхронен. \n   * Поэтому, чтобы получить какую-то доп. структуру к уже имеющейся (например автора от сообщения), \n   * нужно вызвать асинхронную функцию получения кэша. Например: const author = await message.author().\n   * Ещё и по этой причине существует context ивентов.\n   * */\n  \n  if (author.id === '405044179182419980') { // допустим вы хотите чтобы бот реагировал только на вас.\n    \n    if (message.content === '!hello') {\n      // если вы отключили кэш каналов, создавать сообщения нужно вот так:\n      if (!channel) {\n        // channelId гарантированно передаётся в context.\n        message.client.messages.create(channelId, 'world!')\n      } else { // а если канал в кэше есть:\n        channel.send('world!')\n        // можно и так:\n        channel.messages.create('world!')\n        // и так:\n        message.client.messages.create(channel, 'world!')\n      }\n    }\n  }\n  \n  /**\n   * Представим такую ситуацию: вам нужно получить какую-то сущность,\n   * но в context ивента она не передаётся. Как её получить?\n   * Например, referenced message: \n   * */\n  \n  // получит сообщение, на которое отвечает наше, если оно есть в кэше.\n  const referencedMessage = await message.referencedMessage()\n  \n  if (referencedMessage) {\n    // referenced message - такое же сообщение, как и переданное в ивенте, отличающиеся лишь свойствами. \n    console.log(referencedMessage.content)\n    // та же ситуация - получит автора того сообщения, если он есть в кэше.\n    const referencedMessageAuthor = await referencedMessage.author()\n    \n    if (referencedMessageAuthor) {\n      console.log(referencedMessageAuthor.tag)\n    }\n  }\n  \n  /**\n   * На подобном принципе держится всё взаимодействие с библиотекой.\n   * Если что-то нужно - получи из кэша. \n   * Если не нужно - пусть либо не хранится, либо ожидает своего звёздного часа.\n   * */\n  \n})\n```\n"},{"file":"index","dir":"/home/runner/work/guide/guide/guide/guidepp/","content":"---\nhide:\n- toc\n---\n\n# The Advanced Discordoo guide\nHi there! This part of our guide is intended for developers who want to get more advanced in the development of bots using Discordoo.\n\nMore complex things are described here, such as sharding, using and writing your own providers and modules for Discordoo and so on.\n\n## Please\nThis part of the guide is not intended to be read by beginners. If you are a beginner, please read `base guide` before.\n"},{"file":"index.ru","dir":"/home/runner/work/guide/guide/guide/guidepp/","content":"---\nhide:\n- toc\n---\n\n# The Discordoo Guide для продвинутых разработчиков\nДобро пожаловать! Эта часть нашего гайда содержит в себе инструкции по работе с более сложными вещами, нежели в `Base guide`.\n\n## Пожалуйста...\nЭта часть нашего гайда **не для начинающих**. Если вы только начали работу с библиотекой, пожалуйста, прочтите `Base guide` прежде.\n"},{"file":"snowflakes","dir":"/home/runner/work/guide/guide/guide/guidepp/internal-utilities/","content":"# Discordoo Snowflakes\nDiscordooSnowflake is a modified version of Twitter Snowflake.\n\n## Why we use snowflakes\nWe decided to use snowflake as a way to identify sharding instances and as a way to identify interprocess messages.\nEvery time a sharding instance sends a message to sharding manager or vice-versa, a DiscordooSnowflake is created. \nSince interprocess interaction is limited to sending and receiving events, we can't just send a message and get a response. \nWe must somehow understand that this response was exactly to our request. \nThat's why each message is assigned a unique identifier in the form of DiscordooSnowflake.\nWith this unique identifier, we can understand that the response was exactly for us.\n\n![sharding-snowflakes](https://cdn.discordapp.com/attachments/531549268033404928/928052244950175744/sharding-snowflakes.png)\n\n\n## Analyzing Snowflake\nIf we have a snowflake `1128425170719486862453931925225603077` we can represent it as binary:\n```\n128                                        86                               54                               22\n000000001101100101010011101010000000011011 00000000000000000000000000001011 00000000000000000000000001100011 0000000000000000000101\n   number of ms since Discordoo epoch                  worker id                       shard id                    increment\n```\nAfter converting it to a binary, we can allocate individual blocks to find out the information that we used to generate this snowflake.\n\nWe can get timestamp (generation time) from snowflake\n```ts\nconst EPOCH = 1609459200000 // 2021-01-01T00:00:00.000Z\nconst timestamp = (BigInt(snowflake) >> 86n) + BigInt(EPOCH) // 1624043753498n\n```\n\nOr internal worker id (usually, this is the ID of the process that created the snowflake)\n```ts\nconst workerID = (BigInt(snowflake) & 0x3FFFFFFFC0000000000000n) >> 54n // 11n\n```\n\nOr shard id (process, worker or cluster ID, not WebSocketClient (discord shard) id)\n```ts\nconst shardID = (BigInt(snowflake) & 0x3FFFFFFFC00000n) >> 22n // 99n\n```\n \nAnd finally, we can get the snowflake increment (number that increases by 1 for each generation of snowflake on the same process)\n```ts\nconst increment = BigInt(snowflake) & 0x3FFFFFn // 5n\n```\n"},{"file":"snowflakes.ru","dir":"/home/runner/work/guide/guide/guide/guidepp/internal-utilities/","content":"# Идентификаторы \nDiscordooSnowflake это расширенная версия идентификаторов Twitter.\n\n## Зачем нам это\nМы решили создать собственные идентификаторы, такие же как создаёт Discord или Twitter, для того чтобы идентифицировать процессы, созданные ddoo и для пометки сообщений между ними.\nТ.к. межпроцессное взаимодействие сводится лишь к тому, что мы принимаем и отправляем события (а с ними сообщения), нужен был быстрый способ для идентификации этих сообщений, ведь мы не можем просто так взять и получить ответ, нужно понять что этот ответ пришёл именно на наш запрос.\n\n![sharding-snowflakes](../../assets/sharding-snowflakes.png)\n\n## Разбираемся в строении идентификаторов (snowflake => снежинка)\nУ нас есть снежинка `1128425170719486862453931925225603077`, мы можем перевести её в двоичную систему счисления:\n```\n128                                        86                               54                               22\n000000001101100101010011101010000000011011 00000000000000000000000000001011 00000000000000000000000001100011 0000000000000000000101\n  время, прошедшее с Discordoo epoch (мс)            айди воркера                     айди шарда                    прирост\n```\nПосле этой операции, с помощью побитовых операторов JavaScript мы можем разобрать снежинку по частям.\n\nУзнаём временную метку, которую вписали в снежинку когда она была создана:\n```ts\nconst EPOCH = 1609459200000 // EPOCH это временная метка, обозначающая 2021-01-01T00:00:00.000Z\nconst timestamp = (BigInt(snowflake) >> 86n) + BigInt(EPOCH) // время создания снежинки - 1624043753498n \n```\n\nУзнаём айди воркера (обычно это айди процесса на котором сгенерировали снежинку)\n```ts\nconst workerID = (BigInt(snowflake) & 0x3FFFFFFFC0000000000000n) >> 54n // 11n\n```\n\nУзнаём айди экземпляра кластеризации (айди шарда, но не Discord WebSocket шарда)\n```ts\nconst shardID = (BigInt(snowflake) & 0x3FFFFFFFC00000n) >> 22n // 99n\n```\n \nИ наконец узнаём \"прирост\" (число, которое увеличивается на 1 каждый раз, когда новая снежинка генерируется на одном и том же процессе)\n```ts\nconst increment = BigInt(snowflake) & 0x3FFFFFn // 5n\n```\n"},{"file":"index","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Getting started with sharding\n\nSharding is required for bots which have more than 2500 guilds being served.\n\n## Creating sharding manager\nSharding instances (processes, workers or clusters) are managed by ShardingManager.\nIt manages interprocess communication and shard distribution(between processes, machines, etc.).\nIt is a sharp edge of making your bot scalable, so you have to know, how to use it correctly.\n\n1. Create a separate file for sharding manager.\n2. Make sure that this file **is not required** in any way in the sharding instances, otherwise you will get an error about the recursive creation of sharding manager.\n3. Import sharding manager and start it:\n\n=== \"TS\"\n```ts\nimport { ShardingManager } from 'discordoo'\n\nconst manager = new ShardingManager({\n  file: 'C:/path/to/your/old/starting/file.js',\n  shards: 2,\n  mode: 'processes', // you can find other modes in our api documentation\n  processes: { // every mode has its own options\n    shardsPerProcess: 1 // how many discord's shards to run in each sharding instance\n  }\n})\n\nmanager.start()\n  .then(() => 'spawned!')\n```\n"},{"file":"index.ru","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Начало работы с шардингом\n\nШардинг обязателен для ботов, которые имеют более 2500 серверов.\n\n## Шардинг менеджер/менеджер шардов\nЭкземпляры шардинга (процессы, воркеры или кластеры) создаются шардинг менеджером.\nОн занимается обработкой межпроцессных сообщений и распределением шардов между экземплярами шардинга.\nВажно знать о шардинге через шардинг менеджер, потому что это необходимая часть для масштабирования вашего бота.\n\n### Создание шардинг менеджера\n1. Создайте отдельный файл для шардинг менеджера.\n2. Убедитесь что этот файл **никак не запрашивается** (require, import) внутри экземпляра шардинга, иначе вы получите ошибку о рекурсивном создании менеджера шардов, и если вы её не обработаете, node.js остановит исполнение процесса экземпляра шардинга.\n3. В этом файле импортируйте менеджер шардов и запустите его:\n\n=== \"JS\"\n```js\nconst { ShardingManager } = require('discordoo')\n\nconst manager = new ShardingManager({\n  file: 'C:/путь/к/вашему/старому/файлу/запуска.js', \n  // например, если вы запускали бота через node bot.js, то выше нужно указать путь к этому файлу\n  shards: 2, // количество шардов\n  mode: 'processes', // режим шардинга, processes означает создание новых процессов в качестве экземпляров шардинга\n  shardsPerInstance: 1 // сколько gateway (discord) шардов запускать в одном экземпляре, по умолчанию - 1\n})\n\nmanager.start()\n  .then(() => 'spawned!')\n```\n"},{"file":"internals","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Sharding internals\n\nInternally, Discordoo uses `node-ipc` module for interprocess communication. Big thanks to its [authors](https://github.com/sponsors/RIAEvangelist).\n\nEach sharding instance (process, worker or cluster) has a unique DiscordooSnowflake.\nIt is similar to Discord or Twitter snowflake, but modified to suit our needs.\n\n## What happens when a sharding instance is spawned\n**1.** An internal IPC Client is created in the process of the sharding manager.\n\n**2.** Discordoo Snowflake is sent to sharding instance process, which will be used to identify this exact instance.\n\n**3.** An internal IPC Server is created in process of sharding instance, it uses Discordoo Snowflake as an address, a path to itself.\n\n**4.** The IPC Client starts sending an `IpcHelloPacket` to the address passed to the sharding instance process until it receives a response. If 30 seconds have passed, but no response has been received, the sharding instance process will be destroyed.\n\n**5.** If the IPC Server has received an `IpcHelloPacket`, it should send an `IpcIdentifyPacket`. Thus, it informs the IPC Client that it is up and running. `IpcHelloPacket` contains information about how many shards need to be launched, and interval to send heartbeat.\n\n**6.** When the IPC Client receives the `IpcIdentifyPacket`, it will start waiting for the `IpcHeartbeatPacket` from sharding instance. Heartbeat is a system which detects dead sharding instances. IPC Server sends requests to the IPC Client every few seconds and the IPC Client must respond, otherwise IPC Client is considered dead.\n\n**7.** In case of loss of connection with the IPC Client, the IPC Server will command the local client (bot) to self-destruct. In case of loss of connection with the IPC Server, the IPC Client will command the ShardingManager to restart this sharding instance.\n\n## How ShardingManager and sharding instances communicating\nAll communication comes down to a kind of ping-pong. They use a special standardized message type: `IpcPacket`, which is very similar to Discord's WebSocket messages.\n\n| op                                                                      | d                | t                                                                    |\n|-------------------------------------------------------------------------|------------------|----------------------------------------------------------------------|\n| a numeric value, each of the numbers is assigned its own type of event. | mixed JSON data. | when op is 0 (dispatch), here is the string value of the sent event. |\n"},{"file":"internals.ru","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Как работает шардинг изнутри\n\nDiscordoo использует пакет `node-ipc` для пересылки сообщений между шардами. Спасибо его [авторам](https://github.com/sponsors/RIAEvangelist).\n\nКаждый экземпляр шардинга (процесс, воркер или кластер) получает свою [снежинку](../internal-utilities/snowflakes.ru.md).\n\n## Что происходит, когда создаётся экземпляр шардинга\n**1.** IPC (Inter-Process Communication, межпроцессное общение) Клиент создаётся в процессе менеджера шардов.\n\n**2.** [Cнежинка](../internal-utilities/snowflakes.ru.md) передаётся в экземпляр шардинга.\n\n**3.** IPC Сервер создаётся внутри экземпляра шардинга. Он использует переданную ему снежинку в названии Unix/Windows сокета, что позволяет другим процессам найти его и обмениваться сообщениями.\n\n**4.** IPC Клиент начинает отсылать пакет `IpcHelloPacket` на сокет, путь к которому он определил с помощью снежинки. Этот пакет содержит в себе информацию о том, сколько gateway шардов необходимо запустить и через какой интервал необходимо отсылать пакеты \"сердцебиения\" (у каждого Discord бота есть своё маленькое сердечко, которое бьётся раз в какое-то время и отсылает примерно такой же пакет в Discord. А Discord таким образом понимает, мёртв ли бот, который к нему подключился, или нет.). Если IPC Сервер не ответит в течение 30 секунд, экземпляр шардинга будет остановлен и перезапущен.\n\n**5.** Когда IPC Сервер получает пакет `IpcHelloPacket`, он обязан ответить на него пакетом `IpcIdentifyPacket`. Таким образом он информирует IPC Клиент о том что он запущен и работает.\n\n**6.** Когда IPC Клиент получает `IpcIdentifyPacket`, он начинает ждать, пока IPC Сервер не отправит пакет `IpcHeartbeatPacket`. Это называется сердцебиением. IPC Сервер обязан отправлять `IpcHeartbeatPacket` каждые несколько секунд, IPC Клиент обязан отвечать. Таким образом менеджер шардов и экземпляры шардинга понимают, что все процессы активны и работают.\n\n**7.** Если IPC Клиент обнаружит, что не получает `IpcHeartbeatPacket` некоторое время, он остановит экземпляр шардинга и запустит его заново. Если же IPC Сервер обнаружит, что на его пакеты никто не отвечает, он будет следовать инструкциям, переданным в опциях клиента: либо завершит сам себя, либо продолжит работу в автономном режиме.\n\n## Как IPC Клиент и IPC Сервер общаются между собой\nВсё общение сводится к простому пинг-понгу. Пакеты имеют стандартизированный вид - `IpcPacket`, очень похожий на сообщения по WebSocket между Discord и ботом.\n\n| op                                                                      | d                | t                                                                    |\n|-------------------------------------------------------------------------|------------------|----------------------------------------------------------------------|\n| специальный код оперирования, который говорит о том, что нужно делать с этим пакетом. | разная информация в JSON. | если код операции - 0, `t` будет содержать тип события этого пакета, например `RESTRUCTURING`. |\n"},{"file":"machines","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Inter-machines sharding\nIn case of very large bots, it is not enough to shard only on one server.\nTherefore, Discordoo has a mechanism which distributes sharding instances between different servers.\n\n## WARNING\n**THIS IS NOT IMPLEMENTED FOR NOW.**\n\n## Preparing your servers\nYou should prepare your servers to receive sharding instances. To do this, you need to open the port on which Discordoo's ShardingManager will wait for commands from the main ShardingManager. Default port is 8379.\n\n## Getting started\nOn each server, you must install Discordoo and create a ShardingManager in standby mode:\n\n=== \"TS\"\n```ts\nimport { ShardingManager, ShardingManagerModes } from 'discordoo'\n\nconst manager = new ShardingManager({\n  file: 'C:/path/to/your/client/file.js',\n  mode: ShardingManagerModes.MACHINES,\n  machines: {\n    me: 'child',\n    ipc: {\n      networkHost: 'your server IP', // IP of the server on which this sharding manager is running\n    //networkPort: 9999, // override default port if you want\n    },\n    /*tls: {\n      // (this cert used in the array of trusted connections on the main ShardingManager server)\n      public: string // path to server tls cert\n      private: string // path to server tls private key\n      dhparam?: string // path to server dhparam\n      requestCert?: boolean // whether main sharding manager should pass tls cert to this child \n      rejectUnauthorized?: boolean // reject unauthorized connections \n      trustedConnections?: string[] // array of paths to trusted client certificates \n    },*/\n  },\n})\n\nmanager.start()\n```\nOn the main server you should create main ShardingManager and specify machines:\n\n=== \"TS\"\n```ts\nimport { ShardingManager, ShardingManagerModes, ChildShardingModes } from 'discordoo'\n\nconst manager = new ShardingManager({\n  mode: ShardingManagerModes.MACHINES,\n  machines: {\n    me: 'parent',\n    points: [ // array of contact points to your servers\n      {\n        port: 8379, // optional override port \n        host: '10.0.18.1', // remote server ip (required!)\n        udp: 'udp4', // optional UDP instead TCP\n        childManagerOptions: { // options of the sharding manager that will be sent to the remote machine\n          mode: ChildShardingModes.PROCESSES,\n          shards: { from: 0, to: 127 },\n        },\n        tls: {\n          // (this cert used in array of trusted connections on the child sharding manager server)\n          public: '../tls/client.pub', // main ShardingManager tls cert\n          private: '../tls/client.key', // main ShardingMangaer tls private key\n          rejectUnauthorized: true,\n          trustedConnections: [ '../tls/10-0-18-1.pub', '../tls/FE80::0202:B3FF:FE1E:8329.pub' ] // trusted servers tls certs\n        },\n      },\n      {\n        host: 'FE80::0202:B3FF:FE1E:8329', // ipv6 also supported\n        childManagerOptions: {\n          mode: ChildShardingModes.WORKERS,\n          shards: { from: 128, to: 255 },\n        },\n        tls: {\n          public: '../tls/server.pub',\n          private: '../tls/server.key',\n          rejectUnauthorized: true,\n          trustedConnections: [ '../tls/10-0-18-1.pub', '../tls/FE80::0202:B3FF:FE1E:8329.pub' ]\n        },\n      }\n    ]\n  }\n})\n\nmanager.start()\n```\nThat's it!\n"},{"file":"machines.ru","dir":"/home/runner/work/guide/guide/guide/guidepp/sharding/","content":"# Межмашинный шардинг\nВ случае очень больших ботов, один сервер физически не может предоставить столько вычислительной мощности единожды, чтобы бот мог оставаться только на нём. \nДля решения этой проблемы в Discordoo существует механизм межмашинного шардинга. Бот делится на несколько серверов и исполняется параллельно.\n\n## ПРЕДУПРЕЖДЕНИЕ\n**ЭТОТ ФУНКЦИОНАЛ ЕЩЁ НЕ ВВЕДЁН.**\n\n## Подготовка серверов\nВам нужно подготовить ваши сервера для того чтобы они могли исполнять экземпляры шардинга. Чтобы это сделать, вам необходимо в вашем firewall открыть порт, который вы указали для использования в опциях основного менеджера шардов. Если вы не указали порт, то по умолчанию используется 8379.\n\n## Начнём\nНа каждом сервере вы должны установить Discordoo, создать копию вашего бота и перевести менеджер шардов в режим ожидания, затем запустить все менеджеры шардов:\n\n=== \"TS\"\n```ts\nimport { ShardingManager, ShardingManagerModes } from 'discordoo'\n\nconst manager = new ShardingManager({\n  file: 'C:/путь/к/вашему/файлу/старта.js',\n  mode: ShardingManagerModes.MACHINES,\n  machines: {\n    me: 'child', // (вторичный) определяет, является ли менеджер шардов главным или вторичным\n    ipc: {\n      networkHost: 'айпи сервера на котором запущен этот менеджер шардов',\n    //networkPort: 9999, // опционально можно сменить порт, использующщийся для пересылки сообщений между серверами\n    },\n    /*tls: { // опции шифрования передаваемых между серверами данных (РЕКОМЕНДОВАНО)\n      // сертификат public также используется в массиве доверенных сертификатов (trustedConnections) \n      // на машине главного менеджера шардов\n      public: string // путь к сертификату\n      private: string // путь к приватному ключу сертификата\n      dhparam?: string // опционально путь к dhparam, \n      requestCert?: boolean // опционально, true если главный шардинг менеджер обязан предоставить сертификат \n      rejectUnauthorized?: boolean // отключать неавторизованные подключения \n      // массив путей к доверенным сертификатам, \n      // в данном случае 1 путь - к сертификату машины главного менеджера шардов \n      trustedConnections?: string[]\n    },*/\n  },\n})\n\nmanager.start()\n```\nНа главном сервере вам нужно создать и запустить менеджер шардов в режиме \"главный\":\n\n(необязательно выделять отдельный сервер под главный менеджер шардов, удалённым хостом может быть и localhost)\n=== \"TS\"\n```ts\nimport { ShardingManager, ShardingManagerModes, ChildShardingModes } from 'discordoo'\n\nconst manager = new ShardingManager({\n  mode: ShardingManagerModes.MACHINES,\n  machines: {\n    me: 'parent', // (главный) определяет, является ли менеджер шардов главным или вторичным\n    points: [ // массив точек соприкосновения с вашими серверами\n      {\n        port: 8379, // опциональное использование другого порта для пересылки сообщений\n        host: '10.0.18.1', // айпи удалённого хоста (обязательно!)\n        udp: 'udp4', // опциональное использование протокола UDP вместо TCP\n        childManagerOptions: { // опции менеджера шардов, которые будут отправлены на удалённую машину\n          mode: ChildShardingModes.PROCESSES,\n          shards: { from: 0, to: 127 }, // запустить шарды с 0 по 127\n        },\n        tls: {\n          // сертификат public используется в массиве trustedConnections на удалённом хосте\n          public: '../tls/client.pub', // сертификат для главного менеджера шардов \n          private: '../tls/client.key', // приватный ключ сертификата\n          rejectUnauthorized: true, // отключать неавторизованные подключения\n          trustedConnections: [ '../tls/10-0-18-1.pub', '../tls/FE80::0202:B3FF:FE1E:8329.pub' ] // сертификаты с удалённых машин\n        },\n      },\n      {\n        host: 'FE80::0202:B3FF:FE1E:8329', // ipv6 также поддерживается\n        childManagerOptions: {\n          mode: ChildShardingModes.WORKERS,\n          shards: { from: 128, to: 255 }, // запустить шарды с 128 по 255\n        },\n        tls: {\n          public: '../tls/server.pub',\n          private: '../tls/server.key',\n          rejectUnauthorized: true,\n          trustedConnections: [ '../tls/10-0-18-1.pub', '../tls/FE80::0202:B3FF:FE1E:8329.pub' ]\n        },\n      }\n    ]\n  }\n})\n\nmanager.start()\n```\nГотово! Теперь ваш бот разделён на несколько серверов и может продолжать расти. Вам ничего переписывать не нужно, важно только лишь обеспечить быстрое соединение между серверами, иначе большая задержка между отправкой и получением сообщений будет тормозить вашего бота. По нашему мнению, максимально возможная задержка пинг-понг пакетов должна не превышать 50 миллисекунд. В ином случае, задержка станет ощутимой для пользователей. \n"},{"file":"index","dir":"/home/runner/work/guide/guide/guide/","content":"---\ntitle: Hello\nhide:\n- navigation\n- toc\n---\n\n# Discordoo Documentation\nWelcome! This is documentation of Discordoo API in English language.\n\n## WARNING\n**THIS LIBRARY IS UNDER DEVELOPMENT!** All instructions for using the library will be written after the library is released.\n\n## **Important!**\nDiscordoo and this documentation is intended to be used by people, who know what they do, can write/read some basic TypeScript/JavaScript and know how to work with Node.js runtime.\nIf you are a beginner, you should learn language and only after start learning Discordoo.\n\nOf course, you may not learn TS/JS, however, you will not get any support on official support server.\nThe same is applied to those, who ask silly questions like \"how do I answer to slash-commands?\", \"how do I ban a member?\". Answers to these questions are in documentation.\n\n**We will only help you on those questions, that are not answered in documentation.**. \nOr on questions, that are answered in documentation, but are hard to understand and are confusing.\n\n## About documentation\nAbove, there are some sections which are dedicated to each part of the library. \n\n`Advanced guide` tab contains instructions about really hard things, like inter-machines sharding, understanding development process of Rest/Gateway/Cache providers, handling gateway events overloads etc.\n\n`Base guide` tab contains instructions, most of which are needed for all Discord bots.\n\nIf you are just starting using Discordoo, check `Base guide`.\n\n## About library\n### I am already using eris/djs, why should I start using ddoo?\nDiscordoo is made {--because creator is tired of djs--} to make bot development more comfortable,\nsave servers' resources, provide safe ways for developers of big bots to work with gateway/rest and be easy to scale, as well as to create deep integration between developer and library.\n\n#### Eris saves resources of my server and D.js is really comfortable to work with.\nEris is not as comfortable as djs and djs is not as fast as eris. Discordoo has both performance and comfortability. \nHowever, only Evan You can do magic, so eris is most performant of three, but ddoo isn't much slower.\n\n### How to pronounce your library name?\nDiscordoo is pronounced like dɪskɔːdʊ. It can also be pronounced like `Discordo` with stress on last syllable[.](https://www.youtube.com/watch?v=SLTqXW_Gvb0)\n\n## About documentation, but not for developers.\nThis documentation is written by **developers** for **developers**. Prescriptivism is not our objective. Our objective is to explain **developer**, how to use the library. We won't listen to any complaints about `this sentence is hard to read and your documentation sucks!`. If you've found real mistakes in our documentation, we are happy to accept your amends. If you find mistakes like `this sentence sounds bad` and do not do anything, don't waste your time. `It sounds bad! Fix it yourself.` - doesn't help us at all.\n"},{"file":"index.ru","dir":"/home/runner/work/guide/guide/guide/","content":"---\ntitle: Hello\nhide:\n- navigation\n- toc\n---\n\n# Документация Discordoo\nДобро пожаловать! Это документация Discord API библиотеки Discordoo на русском языке.\n\n## ПРЕДУПРЕЖДЕНИЕ\n**ЭТА БИБЛИОТЕКА ЕЩЁ В РАЗРАБОТКЕ!** Все инструкции по использованию библиотеки будут написаны после того, как она выйдет в релиз.\n\n## **Важно!**\nБиблиотека Discordoo и эта документация соответственно предназначены для использования разработчиками, которые знают что делают, умеют читать/писать базовый код на языке TypeScript/JavaScript и знают как работать со средой исполнения Node.js. \nЕсли вы не из таких и только начинаете разрабатывать на вышеперечисленных яп, пожалуйста, сначала выучите язык, потом библиотеку.\n\nВы, конечно, можете и не учить язык прежде, но будьте готовы к тому, что поддержка на нашем Discord сервере вам осуществляться **не будет**. \nЭто также относится к тем, кто задаёт вопросы по типу \"как получить сообщение в канале?\", \"как ответить на слэш-команду?\", \"как мне забанить человека?\" и прочее. Ответы на эти вопросы уже есть в документации. \n\n**Поддержка будет осуществляться только по вопросам, ответов на которые в документации нет**. \nЛибо по действительно сложным вопросам, которые хоть и описаны в документации, но сложны для понимания. \n\n## О документации\nСверху находятся разделы, посвящённые разным частям библиотеки. Для того чтобы URL не отличались от документации на английском, заголовки оставлены без перевода. \n\nВкладки Api и Collection, к сожалению, не могут быть переведены на русский, т.к. генерируются автоматически и процесс перевода встроить не получится.\n\nВкладка `Advanced guide` содержит в себе инструкции о сложных вещах, таких как межмашинный шардинг бота, понимании и разработке Rest/Gateway/Cache провайдеров, обработке перегрузок событий gateway и подобном.\n\nВо вкладке `Base guide` находятся инструкции, большинство из которых вполне вероятно понадобятся при разработке любого Discord бота.\n\nЕсли вы только начинаете разрабатывать ботов используя ddoo, вам во вкладку `Base guide`.\n\n## О библиотеке\n### Я и так использую djs/eris, зачем ddoo?\nDiscordoo создана в первую очередь {--потому что создательнице надоел djs--} для того, чтобы создать больше удобств,\nсэкономить ресурсы серверов, предоставить большИм ботам безопасные решения по работе с gateway/rest и возможность легко масштабироваться, а также, чтобы создать максимально тесную интеграцию между разработчиком и библиотекой.\n\n#### Eris славно экономит ресурсы моего сервера, а с djs мне удобнее некуда\nВ eris нет удобства djs, а в djs нет производительности eris. В ddoo есть и производительность, и удобство, и кастомизация. \nПравда, магией обладает только Evan You, поэтому eris производительнее всех, но всё же уйдя недалеко от ddoo.\n\n### Как произносить ваше название?\nDiscordoo произносится как `дискорду`, с ударением на у, а сокращение `ddoo` должно произноситься как `дду`, но лучше произносить как `ддуу` или как `ддоо`.\nТакже Discordoo можно произносить как `дискордо`, с ударением на первую о[.](https://www.youtube.com/watch?v=SLTqXW_Gvb0)\n\n## О документации, но не разработчикам\nЭта документация написана **разработчиками** для **разработчиков**. Прескриптивизм - не наша цель. Наша цель - объяснить **разработчику**, как работать с этой библиотекой. Мы не хотим использовать длинное тире, короткое тире, два дефиса в ряд и прочую лабудень, которую так любят использовать в некоторых документациях, просто потому что почему нельзя. Мы не хотим слушать лекции о том, что предложение X можно упростить вот так и так, и вообще у меня кровь из глаз от вашего текста. Если вы нашли реальные ошибки в тексте, мы будем только рады вашей помощи. Если же вы находите ошибки по типу \"в этом сложноподчинённом предложении придаточная часть построена не так\", \"это предложение звучит странно\" и при этом ничего не делаете, чтобы помочь исправить ошибку, лично мой, от создательницы этой библиотеки, вам совет: не тратьте ваше и наше время зря. \"Здесь написано не так, а как надо, это вы сами разберитесь\" - не помощь и не участие в поддержке проекта, поэтому потратьте свои силы там, где такую помощь ценят.\n"}],"time":1641337574650,"generator":"@discordoo/tapok 2.0.6"}